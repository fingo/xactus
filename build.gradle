plugins {
    id 'java-library'
    id 'signing'
    id 'maven-publish'
    id 'io.github.gradle-nexus.publish-plugin' version '1.0.0'
}

repositories {
    mavenCentral()
}

extensions.configure(JavaPluginExtension) { javaPluginExtension ->
    javaPluginExtension.toolchain { javaToolchainSec ->
        javaToolchainSec.languageVersion = JavaLanguageVersion.of(8)
    }
}

interface Constants {
    def CODE_GENERATION_TASK_GROUP = 'code generation'
    def CODE_GENERATION_TARGET_DIRECTORY = 'org/eclipse/wst/xml/xpath2/processor/internal'
    def PGP_PROPERTY_KEY_PREFIX = 'signing.pgp.'
    def PGP_SECRET_KEY_PROPERTY_KEY = "${PGP_PROPERTY_KEY_PREFIX}secretKey"
    def PGP_SECRET_KEY_PASSWORD_PROPERTY_KEY = "${PGP_PROPERTY_KEY_PREFIX}secretKeyPassword"
    def PGP_KEY_ID_PROPERTY_KEY = "${PGP_PROPERTY_KEY_PREFIX}keyId"
    def DEPLOYMENT_PROPERTY_KEY_PREFIX = 'deployment.'
    def OSSRH_DEPLOYMENT_PROPERTY_KEY_PREFIX = "${DEPLOYMENT_PROPERTY_KEY_PREFIX}ossrh."
    def OSSRH_USER_NAME_PROPERTY_KEY_PREFIX = "${OSSRH_DEPLOYMENT_PROPERTY_KEY_PREFIX}user"
    def OSSRH_PASSWORD_PROPERTY_KEY_PREFIX = "${OSSRH_DEPLOYMENT_PROPERTY_KEY_PREFIX}password"
    def DEPLOYMENT_VERSION_PROPERTY_KEY = "${DEPLOYMENT_PROPERTY_KEY_PREFIX}version"
    def PUBLICATION_NAME = 'mavenJava'
    def OSSRH_RELEASES_REPO_URL = 'https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/'
    def OSSRH_SNAPSHOT_REPO_URL = 'https://s01.oss.sonatype.org/content/repositories/snapshots/'
}

def generateJFlexTaskProvider = tasks.register('generateJFlex', JavaExec) {
    jFlexExec ->
        def outputDirectory = "$buildDir/jflex-generated"
        def classesDestinationDirectory = file("$outputDirectory/$Constants.CODE_GENERATION_TARGET_DIRECTORY")
        def inputFile = file('src/main/jflex/xpath.lex')

        jFlexExec.group Constants.CODE_GENERATION_TASK_GROUP
        jFlexExec.classpath(configurations.named('jflex'))

        jFlexExec.inputs.file(inputFile)
        jFlexExec.outputs.dir("$outputDirectory")

        jFlexExec.workingDir = classesDestinationDirectory

        jFlexExec.args '-d', classesDestinationDirectory.absolutePath, inputFile.absolutePath

        jFlexExec.doFirst {
            classesDestinationDirectory.mkdirs()
        }
}

def generateJCupTaskProvider = tasks.register('generateJCup', JavaExec) {
    jCupExec ->
        def outputDirectory = "$buildDir/jcup-generated"
        def classesDestinationDirectory = file("$outputDirectory/$Constants.CODE_GENERATION_TARGET_DIRECTORY")
        def inputFile = file('src/main/jcup/xpath.cup')

        jCupExec.group Constants.CODE_GENERATION_TASK_GROUP

        jCupExec.classpath(configurations.named('jcup'))
        jCupExec.main = 'java_cup.Main'

        jCupExec.workingDir = classesDestinationDirectory

        jCupExec.inputs.file(inputFile)
        jCupExec.outputs.dir("$outputDirectory")

        jCupExec.args '-symbols', 'XpathSym', '-parser', 'XPathCup', inputFile.absolutePath

        jCupExec.doFirst {
            classesDestinationDirectory.mkdirs()
        }
}

sourceSets.main.java {
    SourceDirectorySet sourceDirectorySet ->
        sourceDirectorySet.srcDir(generateJCupTaskProvider)
        sourceDirectorySet.srcDir(generateJFlexTaskProvider)
}

configurations {
    jflex
    jcup
    implementation.extendsFrom jcup
}

tasks.named('test', Test).configure {
    it.filter {
        // exclude test suites
        it.excludeTestsMatching('*.All*Tests')
        it.excludeTestsMatching('org.eclipse.wst.xml.xpath2.processor.testutil.legacytestsuiteadapter.PsychopathTestContext')
    }
}

tasks.register('testSuite', Test).configure {
    it.filter {
        it.includeTestsMatching('*.All*Tests')
    }
}

tasks.withType(Test).configureEach {
    it.filter {
        // exclude disabled junit 3 tests
        it.excludeTestsMatching('*.disabled_*')
    }

    it.useJUnitPlatform()
    it.systemProperty 'junit.jupiter.execution.parallel.enabled', 'true'
    it.systemProperty 'junit.jupiter.execution.parallel.mode.default', 'same_thread'
    it.systemProperty 'junit.jupiter.execution.parallel.mode.classes.default', 'concurrent'
    it.systemProperty 'junit.jupiter.execution.parallel.config.strategy', 'dynamic'
}

extensions.configure(JavaPluginExtension) {
    it.withJavadocJar()
    it.withSourcesJar()
}

extensions.configure(PublishingExtension) { publishingExtension ->
    publishingExtension.repositories.maven { MavenArtifactRepository repo ->
        repo.name = 'local'
        repo.url = uri(isSnapshot() ? "$buildDir/repos/snapshots" : "$buildDir/repos/releases")
    }

    publishingExtension.repositories.maven { MavenArtifactRepository repo ->
        repo.name = 'ossrh'
        repo.url = uri(isSnapshot() ? Constants.OSSRH_SNAPSHOT_REPO_URL : Constants.OSSRH_RELEASES_REPO_URL)
        repo.credentials {
            it.username = project.findProperty(Constants.OSSRH_USER_NAME_PROPERTY_KEY_PREFIX).toString()
            it.password = project.findProperty(Constants.OSSRH_PASSWORD_PROPERTY_KEY_PREFIX).toString()
        }
    }

    publishingExtension.publications.register(Constants.PUBLICATION_NAME, MavenPublication) {
        mavenPublication ->
            mavenPublication.artifactId = 'xactus'
            mavenPublication.groupId = 'info.fingo.xactus'
            mavenPublication.version = deploymentVersion
            mavenPublication.from(project.components.getByName('java'))
            mavenPublication.pom { mavenPom ->
                mavenPom.name = 'Xactus'
                mavenPom.url = 'https://github.com/fingo/xactus'
                mavenPom.licenses { licenseSpec ->
                    licenseSpec.license { license ->
                        license.name = 'Eclipse Public License - v 2.0'
                        license.url = 'https://www.eclipse.org/legal/epl-2.0/'
                    }
                }
                mavenPom.scm { mavenPomScm ->
                    mavenPomScm.url = 'https://github.com/fingo/xactus'
                    mavenPomScm.connection = 'scm:git:git://github.com/fingo/xactus'
                }
            }
    }
}

extensions.configure(SigningExtension) {
    if (project.hasProperty(Constants.PGP_SECRET_KEY_PROPERTY_KEY) &&
            project.hasProperty(Constants.PGP_SECRET_KEY_PASSWORD_PROPERTY_KEY)) {
        def pgpSecretKey = project.property(Constants.PGP_SECRET_KEY_PROPERTY_KEY).toString()
        def pgpKeyPassword = project.property(Constants.PGP_SECRET_KEY_PASSWORD_PROPERTY_KEY).toString()

        if (project.hasProperty(Constants.PGP_KEY_ID_PROPERTY_KEY)) {
            it.useInMemoryPgpKeys(project.property(Constants.PGP_KEY_ID_PROPERTY_KEY).toString(), pgpSecretKey, pgpKeyPassword)
        } else {
            it.useInMemoryPgpKeys(pgpSecretKey, pgpKeyPassword)
        }
    }

    it.sign(extensions.findByType(PublishingExtension).publications.getByName(Constants.PUBLICATION_NAME))
}

tasks.named('javadoc', Javadoc).configure {
    it.failOnError = false
}

dependencies {
    implementation 'xerces:xercesImpl:2.12.1'
    implementation 'com.ibm.icu:icu4j:68.2'
    jcup 'edu.princeton.cup:java-cup:10k'
    jflex 'de.jflex:jflex:1.4.3'

    testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
    testImplementation 'org.junit.vintage:junit-vintage-engine:5.7.1'
    testImplementation 'org.xmlunit:xmlunit-core:2.8.2'
    testImplementation 'org.xmlunit:xmlunit-matchers:2.8.2'
    testImplementation 'org.assertj:assertj-core:3.19.0'
    // LSSerializerImpl used to serialize ResultSequence to XML - see AbstractPsychoPathTest#buildXMLResultString
    testImplementation 'xalan:serializer:2.7.2'
}

def getDeploymentVersion() {
    project.findProperty(Constants.DEPLOYMENT_VERSION_PROPERTY_KEY)
}

def isSnapshot() {
    deploymentVersion.toString().endsWith("-SNAPSHOT")
}
