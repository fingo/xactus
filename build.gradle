plugins {
    id 'java-library'
    id 'signing'
    id 'maven-publish'
    id 'io.github.gradle-nexus.publish-plugin' version '1.0.0'
}

repositories {
    mavenCentral()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(8)
    }
}

def codeGenerationTaskGroup = 'code generation'
def generatedCodeDestinationPackageDirectory = 'org/eclipse/wst/xml/xpath2/processor/internal'
def pgpSigningPropertyKeyPrefix = 'signing.pgp.'
def pgpSecretKeyPropertyKey = "${pgpSigningPropertyKeyPrefix}secretKey"
def pgpKeyPasswordPropertyKey = "${pgpSigningPropertyKeyPrefix}secretKeyPassword"
def pgpKeyIdPropertyKey = "${pgpSigningPropertyKeyPrefix}keyId"
def ossrhDeploymentPropertyKeyPrefix = 'deployment.ossrh.'
def ossrhUsernamePropertyKey = "${ossrhDeploymentPropertyKeyPrefix}user"
def ossrhPasswordPropertyKey = "${ossrhDeploymentPropertyKeyPrefix}password"
def publicationName = 'mavenJava'
def ossrhReleasesRepoUri = uri('https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/')
def ossrhSnapshotsRepoUri = uri('https://s01.oss.sonatype.org/content/repositories/snapshots/')
def localReleasesRepoUri = uri("$buildDir/repos/releases")
def localSnapshotsRepoUri = uri("$buildDir/repos/snapshots")

def generateJFlexTaskProvider = tasks.register('generateJFlex', JavaExec) {
    jFlexExec ->
        def outputDirectory = "$buildDir/jflex-generated"
        def classesDestinationDirectory = file("$outputDirectory/$generatedCodeDestinationPackageDirectory")
        def inputFile = file('src/main/jflex/xpath.lex')

        jFlexExec.group codeGenerationTaskGroup
        jFlexExec.classpath(configurations.named('jflex'))

        jFlexExec.inputs.file(inputFile)
        jFlexExec.outputs.dir("$outputDirectory")

        jFlexExec.workingDir = classesDestinationDirectory

        jFlexExec.args '-d', classesDestinationDirectory.absolutePath, inputFile.absolutePath

        jFlexExec.doFirst {
            classesDestinationDirectory.mkdirs()
        }
}

def generateJCupTaskProvider = tasks.register('generateJCup', JavaExec) {
    jCupExec ->
        def outputDirectory = "$buildDir/jcup-generated"
        def classesDestinationDirectory = file("$outputDirectory/$generatedCodeDestinationPackageDirectory")
        def inputFile = file('src/main/jcup/xpath.cup')

        jCupExec.group codeGenerationTaskGroup

        jCupExec.classpath(configurations.named('jcup'))
        jCupExec.main = 'java_cup.Main'

        jCupExec.workingDir = classesDestinationDirectory

        jCupExec.inputs.file(inputFile)
        jCupExec.outputs.dir("$outputDirectory")

        jCupExec.args '-symbols', 'XpathSym', '-parser', 'XPathCup', inputFile.absolutePath

        jCupExec.doFirst {
            classesDestinationDirectory.mkdirs()
        }
}

sourceSets.main.java {
    SourceDirectorySet sourceDirectorySet ->
        sourceDirectorySet.srcDir(generateJCupTaskProvider)
        sourceDirectorySet.srcDir(generateJFlexTaskProvider)
}

configurations {
    jflex
    jcup
    implementation.extendsFrom jcup
}

tasks.named('test', Test).configure {
    it.filter {
        // exclude test suites
        it.excludeTestsMatching('*.All*Tests')
        it.excludeTestsMatching('org.eclipse.wst.xml.xpath2.processor.testutil.legacytestsuiteadapter.PsychopathTestContext')
    }
}

tasks.register('testSuite', Test).configure {
    it.filter {
        it.includeTestsMatching('*.All*Tests')
    }
}

tasks.withType(Test).configureEach {
    it.filter {
        // exclude disabled junit 3 tests
        it.excludeTestsMatching('*.disabled_*')
    }

    it.useJUnitPlatform()
    it.systemProperty 'junit.jupiter.execution.parallel.enabled', 'true'
    it.systemProperty 'junit.jupiter.execution.parallel.mode.default', 'same_thread'
    it.systemProperty 'junit.jupiter.execution.parallel.mode.classes.default', 'concurrent'
    it.systemProperty 'junit.jupiter.execution.parallel.config.strategy', 'dynamic'
}

extensions.configure(JavaPluginExtension) {
    it.withJavadocJar()
    it.withSourcesJar()
}

extensions.configure(PublishingExtension) { publishingExtension ->
    publishingExtension.repositories.maven { MavenArtifactRepository repo ->
        repo.name = 'local'
        repo.url = isSnapshot() ? localSnapshotsRepoUri : localReleasesRepoUri
    }

    publishingExtension.repositories.maven { MavenArtifactRepository repo ->
        repo.name = 'ossrh'
        repo.url = isSnapshot() ? ossrhSnapshotsRepoUri : ossrhReleasesRepoUri
        repo.credentials {
            it.username = project.findProperty(ossrhUsernamePropertyKey).toString()
            it.password = project.findProperty(ossrhPasswordPropertyKey).toString()
        }
    }

    publishingExtension.publications.register(publicationName, MavenPublication) {
        mavenPublication ->
            mavenPublication.artifactId = 'xactus'
            mavenPublication.groupId = 'info.fingo.xactus'
            mavenPublication.version = deploymentVersion
            mavenPublication.from(project.components.getByName('java'))
            mavenPublication.pom { mavenPom ->
                mavenPom.name = 'Xactus'
                mavenPom.url = 'https://github.com/fingo/xactus'
                mavenPom.licenses { licenseSpec ->
                    licenseSpec.license { license ->
                        license.name = 'Eclipse Public License - v 2.0'
                        license.url = 'https://www.eclipse.org/legal/epl-2.0/'
                    }
                }
                mavenPom.scm { mavenPomScm ->
                    mavenPomScm.url = 'https://github.com/fingo/xactus'
                    mavenPomScm.connection = 'scm:git:git://github.com/fingo/xactus'
                }
            }
    }
}

extensions.configure(SigningExtension) {
    if (project.hasProperty(pgpSecretKeyPropertyKey) && project.hasProperty(pgpKeyPasswordPropertyKey)) {
        def pgpSecretKey = project.property(pgpSecretKeyPropertyKey).toString()
        def pgpKeyPassword = project.property(pgpKeyPasswordPropertyKey).toString()

        if (project.hasProperty(pgpKeyIdPropertyKey)) {
            it.useInMemoryPgpKeys(project.property(pgpKeyIdPropertyKey).toString(), pgpSecretKey, pgpKeyPassword)
        } else {
            it.useInMemoryPgpKeys(pgpSecretKey, pgpKeyPassword)
        }
    }

    it.sign(extensions.findByType(PublishingExtension).publications.getByName(publicationName))
}

tasks.named('javadoc', Javadoc).configure {
    it.failOnError = false
}

dependencies {
    implementation 'xerces:xercesImpl:2.12.1'
    implementation 'com.ibm.icu:icu4j:68.2'
    jcup 'edu.princeton.cup:java-cup:10k'
    jflex 'de.jflex:jflex:1.4.3'

    testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
    testImplementation 'org.junit.vintage:junit-vintage-engine:5.7.1'
    testImplementation 'org.xmlunit:xmlunit-core:2.8.2'
    testImplementation 'org.xmlunit:xmlunit-matchers:2.8.2'
    testImplementation 'org.assertj:assertj-core:3.19.0'
    // LSSerializerImpl used to serialize ResultSequence to XML - see AbstractPsychoPathTest#buildXMLResultString
    testImplementation 'xalan:serializer:2.7.2'
}

def getDeploymentVersion() {
    project.version
}

def isSnapshot() {
    deploymentVersion.toString().endsWith("-SNAPSHOT")
}
